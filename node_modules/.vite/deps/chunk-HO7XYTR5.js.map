{
  "version": 3,
  "sources": ["../../zustand/esm/middleware.mjs", "../../zustand/esm/vanilla.mjs", "../../viem/accounts/toAccount.ts", "../../viem/node_modules/ox/core/AbiError.ts", "../../viem/experimental/erc7821/errors.ts", "../../viem/experimental/erc7821/utils/getExecuteError.ts", "../../viem/experimental/erc7821/constants.ts", "../../viem/experimental/erc7821/actions/supportsExecutionMode.ts"],
  "sourcesContent": ["const reduxImpl = (reducer, initial) => (set, _get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return { dispatch: (...a) => api.dispatch(...a), ...initial };\n};\nconst redux = reduxImpl;\n\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api) return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nconst extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === undefined) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e) {\n  }\n  if (!extensionConnector) {\n    return fn(set, get, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = (state, replace, nameOrAction) => {\n    const r = set(state, replace);\n    if (!isRecording) return r;\n    const action = nameOrAction === undefined ? { type: anonymousActionType || \"anonymous\" } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === undefined) {\n      connection == null ? undefined : connection.send(action, get());\n      return r;\n    }\n    connection == null ? undefined : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r;\n  };\n  const setStateFromDevtools = (...a) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set(...a);\n    isRecording = originalIsRecording;\n  };\n  const initialState = fn(api.setState, get, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? undefined : connection.init(initialState);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? undefined : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...a) => {\n      if ((import.meta.env ? import.meta.env.MODE : undefined) !== \"production\" && a[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...a);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === undefined) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format.\n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === undefined || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools) return;\n            if (typeof api.dispatch !== \"function\") return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState);\n            if (store === undefined) {\n              return connection == null ? undefined : connection.init(api.getState());\n            }\n            return connection == null ? undefined : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === undefined) {\n              connection == null ? undefined : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? undefined : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === undefined) {\n                setStateFromDevtools(state);\n                connection == null ? undefined : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? undefined : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === undefined) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? undefined : _a.state;\n            if (!lastComputedState) return;\n            if (store === undefined) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? undefined : connection.send(\n              null,\n              // FIXME no-any\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState;\n};\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, f) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e\n    );\n  }\n  if (parsed !== undefined) f(parsed);\n};\n\nconst subscribeWithSelectorImpl = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = (selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? undefined : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? undefined : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  };\n  const initialState = fn(set, get, api);\n  return initialState;\n};\nconst subscribeWithSelector = subscribeWithSelectorImpl;\n\nconst combine = (initialState, create) => (...a) => Object.assign({}, initialState, create(...a));\n\nfunction createJSONStorage(getStorage, options) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (e) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2, options == null ? undefined : options.reviver);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(\n      name,\n      JSON.stringify(newValue, options == null ? undefined : options.replacer)\n    ),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst persistImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  api.getInitialState = () => configResult;\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a, _b;\n    if (!storage) return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => {\n      var _a2;\n      return cb((_a2 = get()) != null ? _a2 : configResult);\n    });\n    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? undefined : _b.call(options, (_a = get()) != null ? _a : configResult)) || undefined;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            const migration = options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n            if (migration instanceof Promise) {\n              return migration.then((result) => [true, result]);\n            }\n            return [true, migration];\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return [false, deserializedStorageValue.state];\n        }\n      }\n      return [false, undefined];\n    }).then((migrationResult) => {\n      var _a2;\n      const [migrated, migratedState] = migrationResult;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      if (migrated) {\n        return setItem();\n      }\n    }).then(() => {\n      postRehydrationCallback == null ? undefined : postRehydrationCallback(stateFromStorage, undefined);\n      stateFromStorage = get();\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? undefined : postRehydrationCallback(undefined, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? undefined : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  if (!options.skipHydration) {\n    hydrate();\n  }\n  return stateFromStorage || configResult;\n};\nconst persist = persistImpl;\n\nexport { combine, createJSONStorage, devtools, persist, redux, subscribeWithSelector };\n", "const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const api = { setState, getState, getInitialState, subscribe };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\n\nexport { createStore };\n", "// TODO(v3): Rename to `toLocalAccount` + add `source` property to define source (privateKey, mnemonic, hdKey, etc).\n\nimport type { Address } from 'abitype'\n\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../errors/address.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport {\n  type IsAddressErrorType,\n  isAddress,\n} from '../utils/address/isAddress.js'\nimport type {\n  AccountSource,\n  CustomSource,\n  JsonRpcAccount,\n  LocalAccount,\n} from './types.js'\n\ntype GetAccountReturnType<accountSource extends AccountSource> =\n  | (accountSource extends Address ? JsonRpcAccount : never)\n  | (accountSource extends CustomSource ? LocalAccount : never)\n\nexport type ToAccountErrorType =\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\n/**\n * @description Creates an Account from a custom signing implementation.\n *\n * @returns A Local Account.\n */\nexport function toAccount<accountSource extends AccountSource>(\n  source: accountSource,\n): GetAccountReturnType<accountSource> {\n  if (typeof source === 'string') {\n    if (!isAddress(source, { strict: false }))\n      throw new InvalidAddressError({ address: source })\n    return {\n      address: source,\n      type: 'json-rpc',\n    } as GetAccountReturnType<accountSource>\n  }\n\n  if (!isAddress(source.address, { strict: false }))\n    throw new InvalidAddressError({ address: source.address })\n  return {\n    address: source.address,\n    nonceManager: source.nonceManager,\n    sign: source.sign,\n    signAuthorization: source.signAuthorization,\n    signMessage: source.signMessage,\n    signTransaction: source.signTransaction,\n    signTypedData: source.signTypedData,\n    source: 'custom',\n    type: 'local',\n  } as GetAccountReturnType<accountSource>\n}\n", "import * as abitype from 'abitype'\nimport type * as Abi from './Abi.js'\nimport * as AbiItem from './AbiItem.js'\nimport * as AbiParameters from './AbiParameters.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type * as internal from './internal/abiError.js'\nimport type * as AbiItem_internal from './internal/abiItem.js'\nimport type { IsNarrowable, IsNever } from './internal/types.js'\n\n/** Root type for an {@link ox#AbiItem.AbiItem} with an `error` type. */\nexport type AbiError = abitype.AbiError & {\n  hash?: Hex.Hex | undefined\n  overloads?: readonly AbiError[] | undefined\n}\n\n/** @internal */\nexport function decode<\n  const abiError extends AbiError,\n  as extends 'Object' | 'Array' = 'Array',\n>(\n  abiError: abiError,\n  data: Hex.Hex,\n  options?: decode.Options<as> | undefined,\n): decode.ReturnType<abiError, as>\n/**\n * ABI-decodes the provided error input (`inputs`).\n *\n * :::tip\n *\n * This function is typically used to decode contract function reverts (e.g. a JSON-RPC error response).\n *\n * See the [End-to-end Example](#end-to-end).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const error = AbiError.from('error InvalidSignature(uint r, uint s, uint8 yParity)')\n *\n * const value = AbiError.decode(error, '0xecde634900000000000000000000000000000000000000000000000000000000000001a400000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001')\n * // @log: [420n, 69n, 1]\n * ```\n *\n * @example\n * You can extract an ABI Error from a JSON ABI with {@link ox#AbiError.(fromAbi:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([...]) // [!code hl]\n * const error = AbiError.fromAbi(abi, 'InvalidSignature') // [!code hl]\n *\n * const value = AbiError.decode(error, '0xecde634900000000000000000000000000000000000000000000000000000000000001a400000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001')\n * // @log: [420n, 69n, 1]\n * ```\n *\n * @example\n * You can pass the error `data` to the `name` property of {@link ox#AbiError.(fromAbi:function)} to extract and infer the error by its 4-byte selector:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiError } from 'ox'\n *\n * const data = '0xecde634900000000000000000000000000000000000000000000000000000000000001a400000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001'\n *\n * const abi = Abi.from([...])\n * const error = AbiError.fromAbi(abi, data) // [!code hl]\n *\n * const value = AbiError.decode(error, data)\n * // @log: [420n, 69n, 1]\n * ```\n *\n * @example\n * ### ABI-shorthand\n *\n * You can also specify an entire ABI object as a parameter to {@link ox#AbiError.(decode:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([...])\n *\n * const value = AbiError.decode(\n *   abi, // [!code hl]\n *   'InvalidSignature', // [!code hl]\n *   '0x...'\n * )\n * // @log: [420n, 69n, 1]\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiError.decode` to decode the revert error of an `approve` contract call on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).\n *\n * ```ts twoslash\n * // @noErrors\n * import 'ox/window'\n * import { Abi, AbiError, AbiFunction } from 'ox'\n *\n * // 1. Extract the Function from the Contract's ABI.\n * const abi = Abi.from([\n *   // ...\n *   {\n *     inputs: [\n *       { name: 'to', type: 'address' },\n *       { name: 'tokenId', type: 'uint256' },\n *     ],\n *     name: 'approve',\n *     outputs: [],\n *     stateMutability: 'nonpayable',\n *     type: 'function',\n *   },\n *   // ...\n * ])\n * const approve = AbiFunction.fromAbi(abi, 'approve')\n *\n * // 2. Encode the Function Input.\n * const data = AbiFunction.encodeData(\n *   approve,\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * )\n *\n * try {\n *   // 3. Attempt to perform the the Contract Call.\n *   await window.ethereum!.request({\n *     method: 'eth_call',\n *     params: [\n *       {\n *         data,\n *         to: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *       },\n *     ],\n *   })\n * } catch (e) { // [!code focus]\n *   // 4. Extract and decode the Error. // [!code focus]\n *   const error = AbiError.fromAbi(abi, e.data) // [!code focus]\n *   const value = AbiError.decode(error, e.data) // [!code focus]\n *   console.error(`${error.name}(${value})`) // [!code focus]\n * // @error:   Error(ERC721: approve caller is not owner nor approved for all)\n * } // [!code focus]\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiError - The ABI Error to decode.\n * @param data - The error data.\n * @param options - Decoding options.\n * @returns The decoded error.\n */\nexport function decode<\n  const abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n  const args extends\n    | AbiItem_internal.ExtractArgs<abi, name>\n    | undefined = undefined,\n  as extends 'Object' | 'Array' = 'Array',\n  //\n  abiError extends AbiError = AbiItem.fromAbi.ReturnType<\n    abi,\n    name,\n    args,\n    AbiError\n  >,\n  allNames = Name<abi>,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  name: Hex.Hex | (name extends allNames ? name : never),\n  data: Hex.Hex,\n  options?: decode.Options<as> | undefined,\n): decode.ReturnType<abiError, as>\nexport function decode<\n  const abiError extends AbiError,\n  as extends 'Object' | 'Array' = 'Array',\n>(\n  abiError: abiError | AbiError,\n  data: Hex.Hex,\n  options?: decode.Options<as> | undefined,\n): decode.ReturnType<abiError, as>\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decode(\n  ...parameters:\n    | [\n        abi: Abi.Abi | readonly unknown[],\n        name: Hex.Hex | string,\n        data: Hex.Hex,\n        options?: decode.Options | undefined,\n      ]\n    | [abiError: AbiError, data: Hex.Hex, options?: decode.Options | undefined]\n): decode.ReturnType {\n  const [abiError, data, options = {}] = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, name, data, options] = parameters as [\n        Abi.Abi | readonly unknown[],\n        Hex.Hex | string,\n        Hex.Hex,\n        decode.Options | undefined,\n      ]\n      return [fromAbi(abi, name), data, options]\n    }\n    return parameters as [AbiError, Hex.Hex, decode.Options | undefined]\n  })()\n  if (Hex.size(data) < 4) throw new AbiItem.InvalidSelectorSizeError({ data })\n  if (abiError.inputs.length === 0) return undefined\n\n  const values = AbiParameters.decode(\n    abiError.inputs,\n    Hex.slice(data, 4),\n    options,\n  )\n  if (values && Object.keys(values).length === 1) {\n    if (Array.isArray(values)) return values[0]\n    return Object.values(values)[0]\n  }\n  return values\n}\n\nexport declare namespace decode {\n  type Options<as extends 'Object' | 'Array' = 'Array'> = {\n    /**\n     * Whether the decoded values should be returned as an `Object` or `Array`.\n     *\n     * @default \"Array\"\n     */\n    as?: as | 'Array' | 'Object' | undefined\n  }\n\n  type ReturnType<\n    abiError extends AbiError = AbiError,\n    as extends 'Object' | 'Array' = 'Array',\n  > = IsNarrowable<abiError, AbiError> extends true\n    ? abiError['inputs'] extends readonly []\n      ? undefined\n      : abiError['inputs'] extends readonly [\n            infer type extends abitype.AbiParameter,\n          ]\n        ? abitype.AbiParameterToPrimitiveType<type>\n        : AbiParameters.decode.ReturnType<\n              abiError['inputs'],\n              as\n            > extends infer types\n          ? types extends readonly []\n            ? undefined\n            : types extends readonly [infer type]\n              ? type\n              : types\n          : never\n    : unknown | readonly unknown[] | undefined\n\n  type ErrorType =\n    | AbiParameters.decode.ErrorType\n    | Hex.size.ErrorType\n    | typeof AbiItem.InvalidSelectorSizeError\n    | Errors.GlobalErrorType\n}\n\n/**\n * ABI-encodes the provided error input (`inputs`), prefixed with the 4 byte error selector.\n *\n * @example\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const error = AbiError.from(\n *   'error InvalidSignature(uint r, uint s, uint8 yParity)'\n * )\n *\n * const data = AbiError.encode( // [!code focus]\n *   error, // [!code focus]\n *   [1n, 2n, 0] // [!code focus]\n * ) // [!code focus]\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @example\n * ### ABI-shorthand\n *\n * You can also specify an entire ABI object and an error name as parameters to `AbiError.encode`.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([...])\n *\n * const data = AbiError.encode(\n *   abi, // [!code hl]\n *   'InvalidSignature', // [!code hl]\n *   [1n, 2n, 0]\n * )\n * ```\n *\n * @param abiError - ABI Error to encode\n * @param args - Error arguments\n * @returns ABI-encoded error name and arguments\n */\nexport function encode<\n  const abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n  const args extends\n    | AbiItem_internal.ExtractArgs<abi, name>\n    | undefined = undefined,\n  //\n  abiError extends AbiError = AbiItem.fromAbi.ReturnType<\n    abi,\n    name,\n    args,\n    AbiError\n  >,\n  allNames = Name<abi>,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  name: Hex.Hex | (name extends allNames ? name : never),\n  ...args: encode.Args<abiError>\n): encode.ReturnType\nexport function encode<const abiError extends AbiError>(\n  abiError: abiError,\n  ...args: encode.Args<abiError>\n): encode.ReturnType\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function encode(\n  ...parameters:\n    | [\n        abi: Abi.Abi | readonly unknown[],\n        name: Hex.Hex | string,\n        ...args: readonly unknown[],\n      ]\n    | [abiError: AbiError, ...args: readonly unknown[]]\n) {\n  const [abiError, args] = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, name, ...args] = parameters as [\n        Abi.Abi | readonly unknown[],\n        Hex.Hex | string,\n        ...(readonly unknown[]),\n      ]\n      return [fromAbi(abi, name), args]\n    }\n    const [abiError, ...args] = parameters as [\n      AbiError,\n      ...(readonly unknown[]),\n    ]\n    return [abiError, args]\n  })()\n\n  const selector = getSelector(abiError)\n\n  const data =\n    args.length > 0\n      ? AbiParameters.encode(abiError.inputs, (args as any)[0])\n      : undefined\n\n  return data ? Hex.concat(selector, data) : selector\n}\n\nexport declare namespace encode {\n  type Args<abiError extends AbiError = AbiError> = IsNarrowable<\n    abiError,\n    AbiError\n  > extends true\n    ? abitype.AbiParametersToPrimitiveTypes<\n        abiError['inputs']\n      > extends readonly []\n      ? []\n      : [abitype.AbiParametersToPrimitiveTypes<abiError['inputs']>]\n    : readonly unknown[]\n\n  type ReturnType = Hex.Hex\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Formats an {@link ox#AbiError.AbiError} into a **Human Readable ABI Error**.\n *\n * @example\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const formatted = AbiError.format({\n *   type: 'error',\n *   name: 'Example',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiError - The ABI Error to format.\n * @returns The formatted ABI Error.\n */\nexport function format<const abiError extends AbiError>(\n  abiError: abiError | AbiError,\n): abitype.FormatAbiItem<abiError> {\n  return abitype.formatAbiItem(abiError) as never\n}\n\nexport declare namespace format {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Parses an arbitrary **JSON ABI Error** or **Human Readable ABI Error** into a typed {@link ox#AbiError.AbiError}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const badSignatureVError = AbiError.from({\n *   inputs: [{ name: 'v', type: 'uint8' }],\n *   name: 'BadSignatureV',\n *   type: 'error',\n * })\n *\n * badSignatureVError\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const badSignatureVError = AbiError.from(\n *   'error BadSignatureV(uint8 v)' // [!code hl]\n * )\n *\n * badSignatureVError\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const badSignatureVError = AbiError.from([\n *   'struct Signature { uint8 v; }', // [!code hl]\n *   'error BadSignatureV(Signature signature)',\n * ])\n *\n * badSignatureVError\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiError - The ABI Error to parse.\n * @returns Typed ABI Error.\n */\nexport function from<\n  const abiError extends AbiError | string | readonly string[],\n>(\n  abiError: (abiError | AbiError | string | readonly string[]) &\n    (\n      | (abiError extends string ? internal.Signature<abiError> : never)\n      | (abiError extends readonly string[]\n          ? internal.Signatures<abiError>\n          : never)\n      | AbiError\n    ),\n  options: from.Options = {},\n): from.ReturnType<abiError> {\n  return AbiItem.from(abiError as AbiError, options) as never\n}\n\nexport declare namespace from {\n  type Options = {\n    /**\n     * Whether or not to prepare the extracted function (optimization for encoding performance).\n     * When `true`, the `hash` property is computed and included in the returned value.\n     *\n     * @default true\n     */\n    prepare?: boolean | undefined\n  }\n\n  type ReturnType<abiError extends AbiError | string | readonly string[]> =\n    AbiItem.from.ReturnType<abiError>\n\n  type ErrorType = AbiItem.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Extracts an {@link ox#AbiError.AbiError} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Errors can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'error BadSignatureV(uint8 v)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiError.fromAbi(abi, 'BadSignatureV') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Errors can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'error BadSignatureV(uint8 v)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiError.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Error from JSON-RPC error data.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nexport function fromAbi<\n  const abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n  const args extends\n    | AbiItem_internal.ExtractArgs<abi, name>\n    | undefined = undefined,\n  //\n  allNames = Name<abi>,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  name: Hex.Hex | (name extends allNames ? name : never),\n  options?: AbiItem.fromAbi.Options<\n    abi,\n    name,\n    args,\n    AbiItem_internal.ExtractArgs<abi, name>\n  >,\n): fromAbi.ReturnType<abi, name, args> {\n  if (name === 'Error') return solidityError as never\n  if (name === 'Panic') return solidityPanic as never\n  if (Hex.validate(name, { strict: false })) {\n    const selector = Hex.slice(name, 0, 4)\n    if (selector === solidityErrorSelector) return solidityError as never\n    if (selector === solidityPanicSelector) return solidityPanic as never\n  }\n\n  const item = AbiItem.fromAbi(abi, name, options as any)\n  if (item.type !== 'error')\n    throw new AbiItem.NotFoundError({ name, type: 'error' })\n  return item as never\n}\n\nexport declare namespace fromAbi {\n  type ReturnType<\n    abi extends Abi.Abi | readonly unknown[] = Abi.Abi,\n    name extends Name<abi> = Name<abi>,\n    args extends\n      | AbiItem_internal.ExtractArgs<abi, name>\n      | undefined = AbiItem_internal.ExtractArgs<abi, name>,\n  > = IsNarrowable<name, Name<abi>> extends true\n    ?\n        | (name extends 'Error' ? typeof solidityError : never)\n        | (name extends 'Panic'\n            ? typeof solidityPanic\n            : never) extends infer result\n      ? IsNever<result> extends true\n        ? AbiItem.fromAbi.ReturnType<abi, name, args, AbiError>\n        : result\n      : never\n    :\n        | AbiItem.fromAbi.ReturnType<abi, name, args, AbiError>\n        | typeof solidityError\n        | typeof solidityPanic\n\n  type ErrorType = AbiItem.fromAbi.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiError.AbiError}.\n *\n * @example\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const selector = AbiError.getSelector('error BadSignatureV(uint8 v)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const selector = AbiError.getSelector({\n *   inputs: [{ name: 'v', type: 'uint8' }],\n *   name: 'BadSignatureV',\n *   type: 'error'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the error signature.\n */\nexport function getSelector(abiItem: string | AbiError): Hex.Hex {\n  return AbiItem.getSelector(abiItem)\n}\n\nexport declare namespace getSelector {\n  type ErrorType = AbiItem.getSelector.ErrorType | Errors.GlobalErrorType\n}\n\n// https://docs.soliditylang.org/en/v0.8.16/control-structures.html#panic-via-assert-and-error-via-require\nexport const panicReasons = {\n  1: 'An `assert` condition failed.',\n  17: 'Arithmetic operation resulted in underflow or overflow.',\n  18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',\n  33: 'Attempted to convert to an invalid type.',\n  34: 'Attempted to access a storage byte array that is incorrectly encoded.',\n  49: 'Performed `.pop()` on an empty array',\n  50: 'Array index is out of bounds.',\n  65: 'Allocated too much memory or created an array which is too large.',\n  81: 'Attempted to call a zero-initialized variable of internal function type.',\n} as Record<number, string>\n\nexport const solidityError = /*#__PURE__*/ from({\n  inputs: [\n    {\n      name: 'message',\n      type: 'string',\n    },\n  ],\n  name: 'Error',\n  type: 'error',\n})\n\nexport const solidityErrorSelector = '0x08c379a0'\n\nexport const solidityPanic = /*#__PURE__*/ from({\n  inputs: [\n    {\n      name: 'reason',\n      type: 'uint8',\n    },\n  ],\n  name: 'Panic',\n  type: 'error',\n})\n\nexport const solidityPanicSelector = '0x4e487b71'\n\n/**\n * Extracts an {@link ox#AbiError.AbiError} item from an {@link ox#Abi.Abi}, given a name.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([\n *   'error Foo(string)',\n *   'error Bar(uint256)',\n * ])\n *\n * type Foo = AbiError.FromAbi<typeof abi, 'Foo'>\n * //   ^?\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type FromAbi<\n  abi extends Abi.Abi,\n  name extends ExtractNames<abi>,\n> = abitype.ExtractAbiError<abi, name>\n\n/**\n * Extracts the names of all {@link ox#AbiError.AbiError} items in an {@link ox#Abi.Abi}.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([\n *   'error Foo(string)',\n *   'error Bar(uint256)',\n * ])\n *\n * type names = AbiError.Name<typeof abi>\n * //   ^?\n * ```\n */\nexport type Name<abi extends Abi.Abi | readonly unknown[] = Abi.Abi> =\n  abi extends Abi.Abi ? ExtractNames<abi> : string\n\nexport type ExtractNames<abi extends Abi.Abi> =\n  | abitype.ExtractAbiErrorNames<abi>\n  | 'Panic'\n  | 'Error'\n", "import { BaseError } from '../../errors/base.js'\n\nexport type ExecuteUnsupportedErrorType = ExecuteUnsupportedError & {\n  name: 'ExecuteUnsupportedError'\n}\nexport class ExecuteUnsupportedError extends BaseError {\n  constructor() {\n    super('ERC-7821 execution is not supported.', {\n      name: 'ExecuteUnsupportedError',\n    })\n  }\n}\n\nexport type FunctionSelectorNotRecognizedErrorType =\n  FunctionSelectorNotRecognizedError & {\n    name: 'FunctionSelectorNotRecognizedError'\n  }\nexport class FunctionSelectorNotRecognizedError extends BaseError {\n  constructor() {\n    super('Function is not recognized.', {\n      metaMessages: [\n        'This could be due to any of the following:',\n        '  - The contract does not have the function,',\n        '  - The address is not a contract.',\n      ],\n      name: 'FunctionSelectorNotRecognizedError',\n    })\n  }\n}\n", "import type { Abi, Narrow } from 'abitype'\nimport * as AbiError from 'ox/AbiError'\n\nimport type { BaseError } from '../../../errors/base.js'\nimport type { Call, Calls } from '../../../types/calls.js'\nimport type { Hex } from '../../../types/misc.js'\nimport { decodeErrorResult } from '../../../utils/abi/decodeErrorResult.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../../utils/errors/getContractError.js'\nimport {\n  FunctionSelectorNotRecognizedError,\n  type FunctionSelectorNotRecognizedErrorType,\n} from '../errors.js'\n\nexport type GetExecuteErrorParameters<\n  calls extends readonly unknown[] = readonly unknown[],\n> = {\n  /** Calls to execute. */\n  calls: Calls<Narrow<calls>>\n}\n\nexport type GetExecuteErrorReturnType =\n  | FunctionSelectorNotRecognizedErrorType\n  | GetContractErrorReturnType\n\nexport function getExecuteError<const calls extends readonly unknown[]>(\n  e: BaseError,\n  parameters: GetExecuteErrorParameters<calls>,\n): GetExecuteErrorReturnType {\n  const error = e.walk((e) => 'data' in (e as Error)) as\n    | (BaseError & { data?: Hex | undefined })\n    | undefined\n\n  if (!error?.data) return e as never\n  if (\n    error.data ===\n    AbiError.getSelector(AbiError.from('error FnSelectorNotRecognized()'))\n  )\n    return new FunctionSelectorNotRecognizedError() as never\n\n  let matched: Call | null = null\n  for (const c of parameters.calls) {\n    const call = c as Call\n    if (!call.abi) continue\n    try {\n      const matches = Boolean(\n        decodeErrorResult({\n          abi: call.abi,\n          data: error.data!,\n        }),\n      )\n      if (!matches) continue\n      matched = call\n    } catch {}\n  }\n  if (matched)\n    return getContractError(error as BaseError, {\n      abi: matched.abi as Abi,\n      address: matched.to,\n      args: matched.args,\n      functionName: matched.functionName,\n    })\n\n  return e as never\n}\n", "export const abi = [\n  {\n    type: 'fallback',\n    stateMutability: 'payable',\n  },\n  {\n    type: 'receive',\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'execute',\n    inputs: [\n      {\n        name: 'mode',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n      {\n        name: 'executionData',\n        type: 'bytes',\n        internalType: 'bytes',\n      },\n    ],\n    outputs: [],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'supportsExecutionMode',\n    inputs: [\n      {\n        name: 'mode',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n    ],\n    outputs: [\n      {\n        name: 'result',\n        type: 'bool',\n        internalType: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'error',\n    name: 'FnSelectorNotRecognized',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'UnsupportedExecutionMode',\n    inputs: [],\n  },\n] as const\n\nexport const executionMode = {\n  default: '0x0100000000000000000000000000000000000000000000000000000000000000',\n  opData: '0x0100000000007821000100000000000000000000000000000000000000000000',\n  batchOfBatches:\n    '0x0100000000007821000200000000000000000000000000000000000000000000',\n} as const\n", "import type { Address } from '../../../accounts/index.js'\nimport { readContract } from '../../../actions/public/readContract.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport { withCache } from '../../../utils/promise/withCache.js'\nimport { abi, executionMode } from '../constants.js'\n\nexport type SupportsExecutionModeParameters = {\n  address: Address\n  mode?: 'default' | 'opData' | 'batchOfBatches' | Hex\n}\n\nexport type SupportsExecutionModeReturnType = boolean\n\nexport type SupportsExecutionModeErrorType = ErrorType\n\nconst toSerializedMode = {\n  default: executionMode.default,\n  opData: executionMode.opData,\n  batchOfBatches: executionMode.batchOfBatches,\n} as const\n\n/**\n * Checks if the contract supports the ERC-7821 execution mode.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { supportsExecutionMode } from 'viem/experimental/erc7821'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const supported = await supportsExecutionMode(client, {\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * })\n * ```\n *\n * @param client - Client to use.\n * @param parameters - {@link SupportsExecutionModeParameters}\n * @returns If the execution mode is supported. {@link SupportsExecutionModeReturnType}\n */\nexport async function supportsExecutionMode<\n  chain extends Chain | undefined = Chain | undefined,\n>(\n  client: Client<Transport, chain>,\n  parameters: SupportsExecutionModeParameters,\n): Promise<SupportsExecutionModeReturnType> {\n  const { address, mode: m = 'default' } = parameters\n  const mode = m.startsWith('0x') ? m : (toSerializedMode as any)[m]\n  try {\n    return await withCache(\n      () =>\n        readContract(client, {\n          abi,\n          address,\n          functionName: 'supportsExecutionMode',\n          args: [mode],\n        }),\n      {\n        cacheKey: `supportsExecutionMode.${address}.${mode}`,\n      },\n    )\n  } catch {\n    return false\n  }\n}\n"],
  "mappings": "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",
  "names": ["from", "getSelector", "from", "from", "e", "getSelector", "from"]
}
