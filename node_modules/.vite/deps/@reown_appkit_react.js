import {
  AppKitAccountButton,
  AppKitButton,
  AppKitConnectButton,
  AppKitNetworkButton
} from "./chunk-65YWZ2AW.js";
import "./chunk-O6OTPQWS.js";
import "./chunk-QR3UFHZ3.js";
import "./chunk-TAFLE73G.js";
import "./chunk-NA4IIH2W.js";
import "./chunk-SO2V5KBE.js";
import "./chunk-5XPNDNG5.js";
import "./chunk-NRYAHKJ6.js";
import "./chunk-ZIPUXI5F.js";
import "./chunk-ILJSQKZB.js";
import "./chunk-LZIZMLSI.js";
import "./chunk-OIYDSCA7.js";
import "./chunk-AKQFM4VG.js";
import "./chunk-IO5376T3.js";
import "./chunk-B5NYQBQR.js";
import "./chunk-E3AEHS2H.js";
import "./chunk-LD4QFRZW.js";
import "./chunk-KJ646P2O.js";
import "./chunk-O5YUAOTY.js";
import "./chunk-JQJXYRDP.js";
import "./chunk-HNB35IZC.js";
import "./chunk-ZJSPVTKF.js";
import "./chunk-BNIYGRGF.js";
import "./chunk-DFVMXRS5.js";
import "./chunk-6QOWD2HI.js";
import "./chunk-4MP3TBEL.js";
import "./chunk-ITOH3UNU.js";
import "./chunk-FS3CSUOV.js";
import "./chunk-PSX5PQKI.js";
import "./chunk-U3YSUN5A.js";
import "./chunk-7AW7HMH6.js";
import "./chunk-NXL3DZWX.js";
import "./chunk-7IU3OMM4.js";
import "./chunk-CGXHVTOC.js";
import "./chunk-F73ZQCAB.js";
import "./chunk-UDBXVWYO.js";
import "./chunk-G4SBRMFG.js";
import "./chunk-Q66EEJKM.js";
import "./chunk-NJDE5NWY.js";
import {
  AppKit,
  PACKAGE_VERSION,
  WcConstantsUtil
} from "./chunk-U72PFRSM.js";
import "./chunk-HMDFPBFA.js";
import "./chunk-627XIL5L.js";
import "./chunk-XZRGYLS3.js";
import "./chunk-ESOWI2G7.js";
import {
  require_react
} from "./chunk-WHMHXUZ4.js";
import "./chunk-F6OOSJ2R.js";
import "./chunk-AM27SWWN.js";
import {
  AlertController
} from "./chunk-AVC7L62Q.js";
import "./chunk-TTJ6PQO6.js";
import "./chunk-OR67L7UC.js";
import "./chunk-F6XJSCRZ.js";
import "./chunk-U6643BKF.js";
import "./chunk-2YULO2GZ.js";
import {
  AssetController,
  AssetUtil,
  ChainController,
  ConnectionController,
  ConnectionControllerUtil,
  ConnectorController,
  CoreHelperUtil,
  OptionsController,
  ProviderController,
  StorageUtil
} from "./chunk-3XOEPFNB.js";
import {
  affectedToPathList,
  createProxy,
  isChanged,
  snapshot,
  subscribe
} from "./chunk-FUV7PBD3.js";
import "./chunk-PKKOUJRU.js";
import "./chunk-YQGIPIDQ.js";
import "./chunk-6ATGLH2D.js";
import "./chunk-ZO77EUZE.js";
import "./chunk-G3HFAHDV.js";
import "./chunk-4B53ZGGF.js";
import "./chunk-G3VRPRTL.js";
import "./chunk-KASMAJTU.js";
import {
  ConstantsUtil
} from "./chunk-UZRBU537.js";
import "./chunk-PJYFN5YR.js";
import "./chunk-G2R45Z6F.js";
import "./chunk-3NIYQQ3T.js";
import "./chunk-ZKD6ANST.js";
import "./chunk-VKJLEXYM.js";
import {
  __toESM
} from "./chunk-MMN2DTB3.js";

// node_modules/@reown/appkit-controllers/dist/esm/exports/react.js
var import_react2 = __toESM(require_react());

// node_modules/valtio/esm/react.mjs
var import_react = __toESM(require_react(), 1);
var useAffectedDebugValue = (state, affected) => {
  const pathList = (0, import_react.useRef)(void 0);
  (0, import_react.useEffect)(() => {
    pathList.current = affectedToPathList(state, affected, true);
  });
  (0, import_react.useDebugValue)(pathList.current);
};
var condUseAffectedDebugValue = useAffectedDebugValue;
var targetCache = /* @__PURE__ */ new WeakMap();
function useSnapshot(proxyObject, options) {
  const notifyInSync = options == null ? void 0 : options.sync;
  const affected = (0, import_react.useMemo)(
    () => proxyObject && /* @__PURE__ */ new WeakMap(),
    [proxyObject]
  );
  const lastSnapshot = (0, import_react.useRef)(void 0);
  let inRender = true;
  const currSnapshot = (0, import_react.useSyncExternalStore)(
    (0, import_react.useCallback)(
      (callback) => {
        const unsub = subscribe(proxyObject, callback, notifyInSync);
        callback();
        return unsub;
      },
      [proxyObject, notifyInSync]
    ),
    () => {
      const nextSnapshot = snapshot(proxyObject);
      try {
        if (!inRender && lastSnapshot.current && !isChanged(
          lastSnapshot.current,
          nextSnapshot,
          affected,
          /* @__PURE__ */ new WeakMap()
        )) {
          return lastSnapshot.current;
        }
      } catch (e) {
      }
      return nextSnapshot;
    },
    () => snapshot(proxyObject)
  );
  inRender = false;
  (0, import_react.useLayoutEffect)(() => {
    lastSnapshot.current = currSnapshot;
  });
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
    condUseAffectedDebugValue(currSnapshot, affected);
  }
  const proxyCache = (0, import_react.useMemo)(() => /* @__PURE__ */ new WeakMap(), []);
  return createProxy(currSnapshot, affected, proxyCache, targetCache);
}

// node_modules/@reown/appkit-controllers/dist/esm/exports/react.js
function useAppKitProvider(chainNamespace) {
  const { providers, providerIds } = useSnapshot(ProviderController.state);
  const walletProvider = providers[chainNamespace];
  const walletProviderType = providerIds[chainNamespace];
  return {
    walletProvider,
    walletProviderType
  };
}
function useAppKitNetworkCore() {
  const { activeCaipNetwork } = useSnapshot(ChainController.state);
  return {
    caipNetwork: activeCaipNetwork,
    chainId: activeCaipNetwork?.id,
    caipNetworkId: activeCaipNetwork?.caipNetworkId
  };
}
function useAppKitAccount(options) {
  const state = useSnapshot(ChainController.state);
  const { activeConnectorIds } = useSnapshot(ConnectorController.state);
  const chainNamespace = options?.namespace || state.activeChain;
  if (!chainNamespace) {
    return {
      allAccounts: [],
      address: void 0,
      caipAddress: void 0,
      status: void 0,
      isConnected: false,
      embeddedWalletInfo: void 0
    };
  }
  const chainAccountState = state.chains.get(chainNamespace)?.accountState;
  const authConnector = ConnectorController.getAuthConnector(chainNamespace);
  const activeConnectorId = activeConnectorIds[chainNamespace];
  const connections = ConnectionController.getConnections(chainNamespace);
  const allAccounts = connections.flatMap((connection) => connection.accounts.map(({ address, type, publicKey }) => CoreHelperUtil.createAccount(chainNamespace, address, type || "eoa", publicKey)));
  return {
    allAccounts,
    caipAddress: chainAccountState?.caipAddress,
    address: CoreHelperUtil.getPlainAddress(chainAccountState?.caipAddress),
    isConnected: Boolean(chainAccountState?.caipAddress),
    status: chainAccountState?.status,
    embeddedWalletInfo: authConnector && activeConnectorId === ConstantsUtil.CONNECTOR_ID.AUTH ? {
      user: chainAccountState?.user ? {
        ...chainAccountState.user,
        /*
         * Getting the username from the chain controller works well for social logins,
         * but Farcaster uses a different connection flow and doesn’t emit the username via events.
         * Since the username is stored in local storage before the chain controller updates,
         * it’s safe to use the local storage value here.
         */
        username: StorageUtil.getConnectedSocialUsername()
      } : void 0,
      authProvider: chainAccountState?.socialProvider || "email",
      accountType: chainAccountState?.preferredAccountType,
      isSmartAccountDeployed: Boolean(chainAccountState?.smartAccountDeployed)
    } : void 0
  };
}
function useDisconnect() {
  async function disconnect(props) {
    await ConnectionController.disconnect(props);
  }
  return { disconnect };
}
function useAppKitConnections(namespace) {
  useSnapshot(ConnectionController.state);
  useSnapshot(ConnectorController.state);
  useSnapshot(AssetController.state);
  const { activeChain } = useSnapshot(ChainController.state);
  const { remoteFeatures } = useSnapshot(OptionsController.state);
  const chainNamespace = namespace ?? activeChain;
  const isMultiWalletEnabled = Boolean(remoteFeatures?.multiWallet);
  if (!chainNamespace) {
    throw new Error("No namespace found");
  }
  if (!isMultiWalletEnabled) {
    AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.CONNECTIONS_HOOK, "info");
    return {
      connections: [],
      recentConnections: []
    };
  }
  const { connections, recentConnections } = ConnectionControllerUtil.getConnectionsData(chainNamespace);
  const formatConnection = (0, import_react2.useCallback)((connection) => {
    const connector = ConnectorController.getConnectorById(connection.connectorId);
    const name = ConnectorController.getConnectorName(connector?.name);
    const icon = AssetUtil.getConnectorImage(connector);
    const networkImage = AssetUtil.getNetworkImage(connection.caipNetwork);
    return {
      name,
      icon,
      networkIcon: networkImage,
      ...connection
    };
  }, []);
  return {
    connections: connections.map(formatConnection),
    recentConnections: recentConnections.map(formatConnection)
  };
}
function useAppKitConnection({ namespace, onSuccess, onError }) {
  const { connections, isSwitchingConnection } = useSnapshot(ConnectionController.state);
  const { activeConnectorIds } = useSnapshot(ConnectorController.state);
  const { activeChain } = useSnapshot(ChainController.state);
  const { remoteFeatures } = useSnapshot(OptionsController.state);
  const chainNamespace = namespace ?? activeChain;
  if (!chainNamespace) {
    throw new Error("No namespace found");
  }
  const isMultiWalletEnabled = Boolean(remoteFeatures?.multiWallet);
  if (!isMultiWalletEnabled) {
    AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.CONNECTION_HOOK, "info");
    return {
      connection: void 0,
      isPending: false,
      switchConnection: () => Promise.resolve(void 0),
      deleteConnection: () => ({})
    };
  }
  const connectorId = activeConnectorIds[chainNamespace];
  const connList = connections.get(chainNamespace);
  const connection = connList?.find((c) => c.connectorId.toLowerCase() === connectorId?.toLowerCase());
  const switchConnection = (0, import_react2.useCallback)(async ({ connection: _connection, address }) => {
    try {
      ConnectionController.setIsSwitchingConnection(true);
      await ConnectionController.switchConnection({
        connection: _connection,
        address,
        namespace: chainNamespace,
        onChange({ address: newAddress, namespace: newNamespace, hasSwitchedAccount, hasSwitchedWallet }) {
          onSuccess?.({
            address: newAddress,
            namespace: newNamespace,
            hasSwitchedAccount,
            hasSwitchedWallet,
            hasDeletedWallet: false
          });
        }
      });
    } catch (err) {
      const error = err instanceof Error ? err : new Error("Something went wrong");
      onError?.(error);
    } finally {
      ConnectionController.setIsSwitchingConnection(false);
    }
  }, [chainNamespace, onSuccess, onError]);
  const deleteConnection = (0, import_react2.useCallback)(({ address, connectorId: connectorId2 }) => {
    StorageUtil.deleteAddressFromConnection({ connectorId: connectorId2, address, namespace: chainNamespace });
    ConnectionController.syncStorageConnections();
    onSuccess?.({
      address,
      namespace: chainNamespace,
      hasSwitchedAccount: false,
      hasSwitchedWallet: false,
      hasDeletedWallet: true
    });
  }, [chainNamespace]);
  return {
    connection,
    isPending: isSwitchingConnection,
    switchConnection,
    deleteConnection
  };
}

// node_modules/@reown/appkit/dist/esm/src/library/react/index.js
var import_react3 = __toESM(require_react(), 1);
var modal = void 0;
function getAppKit(appKit) {
  if (appKit) {
    modal = appKit;
  }
}
function useAppKitTheme() {
  if (!modal) {
    throw new Error('Please call "createAppKit" before using "useAppKitTheme" hook');
  }
  function setThemeMode(themeMode2) {
    if (themeMode2) {
      modal?.setThemeMode(themeMode2);
    }
  }
  function setThemeVariables(themeVariables2) {
    if (themeVariables2) {
      modal?.setThemeVariables(themeVariables2);
    }
  }
  const [themeMode, setInternalThemeMode] = (0, import_react3.useState)(modal.getThemeMode());
  const [themeVariables, setInternalThemeVariables] = (0, import_react3.useState)(modal.getThemeVariables());
  (0, import_react3.useEffect)(() => {
    const unsubscribe = modal?.subscribeTheme((state) => {
      setInternalThemeMode(state.themeMode);
      setInternalThemeVariables(state.themeVariables);
    });
    return () => {
      unsubscribe?.();
    };
  }, []);
  return {
    themeMode,
    themeVariables,
    setThemeMode,
    setThemeVariables
  };
}
function useAppKit() {
  if (!modal) {
    throw new Error('Please call "createAppKit" before using "useAppKit" hook');
  }
  async function open(options) {
    return modal?.open(options);
  }
  async function close() {
    await modal?.close();
  }
  return { open, close };
}
function useWalletInfo(namespace) {
  if (!modal) {
    throw new Error('Please call "createAppKit" before using "useWalletInfo" hook');
  }
  const [walletInfo, setWalletInfo] = (0, import_react3.useState)(() => modal?.getWalletInfo(namespace));
  (0, import_react3.useEffect)(() => {
    setWalletInfo(modal?.getWalletInfo(namespace));
    const unsubscribe = modal?.subscribeWalletInfo((newWalletInfo) => {
      setWalletInfo(newWalletInfo);
    }, namespace);
    return () => unsubscribe?.();
  }, [namespace]);
  return { walletInfo };
}
function useAppKitState() {
  if (!modal) {
    throw new Error('Please call "createAppKit" before using "useAppKitState" hook');
  }
  const [state, setState] = (0, import_react3.useState)({ ...modal.getState(), initialized: false });
  const [remoteFeatures, setRemoteFeatures] = (0, import_react3.useState)(modal.getRemoteFeatures());
  (0, import_react3.useEffect)(() => {
    if (modal) {
      setState({ ...modal.getState() });
      setRemoteFeatures(modal.getRemoteFeatures());
      const unsubscribe = modal?.subscribeState((newState) => {
        setState({ ...newState });
      });
      const unsubscribeRemoteFeatures = modal?.subscribeRemoteFeatures((newState) => {
        setRemoteFeatures(newState);
      });
      return () => {
        unsubscribe?.();
        unsubscribeRemoteFeatures?.();
      };
    }
    return () => null;
  }, []);
  return { ...state, ...remoteFeatures ?? {} };
}
function useAppKitEvents() {
  if (!modal) {
    throw new Error('Please call "createAppKit" before using "useAppKitEvents" hook');
  }
  const [event, setEvents] = (0, import_react3.useState)(modal.getEvent());
  (0, import_react3.useEffect)(() => {
    const unsubscribe = modal?.subscribeEvents((newEvent) => {
      setEvents({ ...newEvent });
    });
    return () => {
      unsubscribe?.();
    };
  }, []);
  return event;
}

// node_modules/@reown/appkit/dist/esm/src/utils/BalanceUtil.js
async function _internalFetchBalance(appKit) {
  if (!appKit) {
    throw new Error("AppKit not initialized when  fetchBalance was called.");
  }
  return await updateBalance(appKit);
}
async function updateBalance(appKit) {
  const address = appKit.getAddress();
  const chainNamespace = appKit.getActiveChainNamespace();
  const chainId = appKit.getCaipNetwork()?.id;
  if (!address || !chainNamespace || !chainId) {
    return {
      data: void 0,
      error: "Not able to retrieve balance",
      isSuccess: false,
      isError: true
    };
  }
  const balance = await appKit.updateNativeBalance(address, chainId, chainNamespace);
  return {
    data: balance,
    error: balance ? null : "No balance found",
    isSuccess: Boolean(balance),
    isError: !balance
  };
}

// node_modules/@reown/appkit/dist/esm/src/library/react/components.js
var import_react4 = __toESM(require_react(), 1);

// node_modules/@lit/react/development/create-component.js
var NODE_MODE = false;
var DEV_MODE = true;
var reservedReactProperties = /* @__PURE__ */ new Set([
  "children",
  "localName",
  "ref",
  "style",
  "className"
]);
var listenedEvents = /* @__PURE__ */ new WeakMap();
var addOrUpdateEventListener = (node, event, listener) => {
  let events = listenedEvents.get(node);
  if (events === void 0) {
    listenedEvents.set(node, events = /* @__PURE__ */ new Map());
  }
  let handler = events.get(event);
  if (listener !== void 0) {
    if (handler === void 0) {
      events.set(event, handler = { handleEvent: listener });
      node.addEventListener(event, handler);
    } else {
      handler.handleEvent = listener;
    }
  } else if (handler !== void 0) {
    events.delete(event);
    node.removeEventListener(event, handler);
  }
};
var setProperty = (node, name, value, old, events) => {
  const event = events?.[name];
  if (event !== void 0) {
    if (value !== old) {
      addOrUpdateEventListener(node, event, value);
    }
    return;
  }
  node[name] = value;
  if ((value === void 0 || value === null) && name in HTMLElement.prototype) {
    node.removeAttribute(name);
  }
};
var createComponent = ({ react: React2, tagName, elementClass, events, displayName }) => {
  const eventProps = new Set(Object.keys(events ?? {}));
  if (DEV_MODE && !NODE_MODE) {
    for (const p of reservedReactProperties) {
      if (p in elementClass.prototype && !(p in HTMLElement.prototype)) {
        console.warn(`${tagName} contains property ${p} which is a React reserved property. It will be used by React and not set on the element.`);
      }
    }
  }
  const ReactComponent = React2.forwardRef((props, ref) => {
    const prevElemPropsRef = React2.useRef(/* @__PURE__ */ new Map());
    const elementRef = React2.useRef(null);
    const reactProps = {};
    const elementProps = {};
    for (const [k, v] of Object.entries(props)) {
      if (reservedReactProperties.has(k)) {
        reactProps[k === "className" ? "class" : k] = v;
        continue;
      }
      if (eventProps.has(k) || k in elementClass.prototype) {
        elementProps[k] = v;
        continue;
      }
      reactProps[k] = v;
    }
    if (!NODE_MODE) {
      React2.useLayoutEffect(() => {
        if (elementRef.current === null) {
          return;
        }
        const newElemProps = /* @__PURE__ */ new Map();
        for (const key in elementProps) {
          setProperty(elementRef.current, key, props[key], prevElemPropsRef.current.get(key), events);
          prevElemPropsRef.current.delete(key);
          newElemProps.set(key, props[key]);
        }
        for (const [key, value] of prevElemPropsRef.current) {
          setProperty(elementRef.current, key, void 0, value, events);
        }
        prevElemPropsRef.current = newElemProps;
      });
      React2.useLayoutEffect(() => {
        elementRef.current?.removeAttribute("defer-hydration");
      }, []);
    }
    if (NODE_MODE) {
      if ((React2.createElement.name === "litPatchedCreateElement" || globalThis.litSsrReactEnabled) && Object.keys(elementProps).length) {
        reactProps["_$litProps$"] = elementProps;
      }
    } else {
      reactProps["suppressHydrationWarning"] = true;
    }
    return React2.createElement(tagName, {
      ...reactProps,
      ref: React2.useCallback((node) => {
        elementRef.current = node;
        if (typeof ref === "function") {
          ref(node);
        } else if (ref !== null) {
          ref.current = node;
        }
      }, [ref])
    });
  });
  ReactComponent.displayName = displayName ?? elementClass.name;
  return ReactComponent;
};

// node_modules/@reown/appkit/dist/esm/src/library/react/components.js
var AppKitButton2 = createComponent({
  tagName: "appkit-button",
  elementClass: AppKitButton,
  react: import_react4.default
});
var AppKitNetworkButton2 = createComponent({
  tagName: "appkit-network-button",
  elementClass: AppKitNetworkButton,
  react: import_react4.default
});
var AppKitConnectButton2 = createComponent({
  tagName: "appkit-connect-button",
  elementClass: AppKitConnectButton,
  react: import_react4.default
});
var AppKitAccountButton2 = createComponent({
  tagName: "appkit-account-button",
  elementClass: AppKitAccountButton,
  react: import_react4.default
});

// node_modules/@reown/appkit/dist/esm/src/library/react/providers.js
var import_react6 = __toESM(require_react(), 1);
var appkit = null;
function memoizeCreateAppKit(config) {
  if (!appkit) {
    appkit = createAppKit(config);
  }
  return appkit;
}
function AppKitProvider({ children, ...props }) {
  memoizeCreateAppKit(props);
  return children;
}

// node_modules/@reown/appkit/dist/esm/exports/react.js
var modal2 = void 0;
function createAppKit(options) {
  if (!modal2) {
    modal2 = new AppKit({
      ...options,
      sdkVersion: CoreHelperUtil.generateSdkVersion(options.adapters ?? [], "react", PACKAGE_VERSION)
    });
    getAppKit(modal2);
  }
  return modal2;
}
function useAppKitNetwork() {
  const { caipNetwork, caipNetworkId, chainId } = useAppKitNetworkCore();
  async function switchNetwork(network) {
    await modal2?.switchNetwork(network);
  }
  return {
    caipNetwork,
    caipNetworkId,
    chainId,
    switchNetwork
  };
}
function useAppKitBalance() {
  async function fetchBalance() {
    return await _internalFetchBalance(modal2);
  }
  return {
    fetchBalance
  };
}
export {
  AppKit,
  AppKitAccountButton2 as AppKitAccountButton,
  AppKitButton2 as AppKitButton,
  AppKitConnectButton2 as AppKitConnectButton,
  AppKitNetworkButton2 as AppKitNetworkButton,
  AppKitProvider,
  CoreHelperUtil,
  WcConstantsUtil,
  createAppKit,
  getAppKit,
  modal2 as modal,
  useAppKit,
  useAppKitAccount,
  useAppKitBalance,
  useAppKitConnection,
  useAppKitConnections,
  useAppKitEvents,
  useAppKitNetwork,
  useAppKitNetworkCore,
  useAppKitProvider,
  useAppKitState,
  useAppKitTheme,
  useDisconnect,
  useWalletInfo
};
/*! Bundled license information:

@lit/react/development/create-component.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/react/development/index.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=@reown_appkit_react.js.map
