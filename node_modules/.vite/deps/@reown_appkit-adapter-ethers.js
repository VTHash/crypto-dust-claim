import {
  BrowserProvider,
  Contract,
  JsonRpcProvider,
  JsonRpcSigner,
  formatEther,
  formatUnits,
  getAddress,
  hexlify,
  isHexString,
  parseUnits,
  toUtf8Bytes
} from "./chunk-KC4TKGYS.js";
import {
  WcConstantsUtil
} from "./chunk-6BZHVWVN.js";
import {
  ConnectorUtil
} from "./chunk-BBO35EX5.js";
import "./chunk-627XIL5L.js";
import {
  ConstantsUtil as ConstantsUtil2,
  HelpersUtil,
  PresetsUtil
} from "./chunk-ZNMSFBKV.js";
import {
  AdapterBlueprint,
  SIWXUtil,
  WalletConnectConnector,
  WcHelpersUtil
} from "./chunk-EUUS47WX.js";
import "./chunk-4Z2ZRXRP.js";
import "./chunk-HXNQWV53.js";
import {
  AssetController,
  ChainController,
  CoreHelperUtil,
  OptionsController,
  ProviderController,
  StorageUtil,
  getPreferredAccountType
} from "./chunk-3SZNDMDM.js";
import "./chunk-OM232EKQ.js";
import "./chunk-MKHIKSHD.js";
import "./chunk-QYJ4ANVU.js";
import "./chunk-KASMAJTU.js";
import {
  ConstantsUtil,
  ErrorUtil,
  ParseUtil,
  UserRejectedRequestError
} from "./chunk-FXZREKKU.js";
import "./chunk-G2R45Z6F.js";
import "./chunk-3NIYQQ3T.js";
import "./chunk-ZKD6ANST.js";
import "./chunk-VKJLEXYM.js";
import "./chunk-DI52DQAC.js";

// node_modules/@reown/appkit-utils/dist/esm/src/ethers/EthersHelpersUtil.js
var EthersHelpersUtil = {
  hexStringToNumber(value) {
    const string = value.startsWith("0x") ? value.slice(2) : value;
    const number = parseInt(string, 16);
    return number;
  },
  numberToHexString(value) {
    return `0x${value.toString(16)}`;
  },
  async getUserInfo(provider) {
    const [addresses, chainId] = await Promise.all([
      EthersHelpersUtil.getAddresses(provider),
      EthersHelpersUtil.getChainId(provider)
    ]);
    return { chainId, addresses };
  },
  async getChainId(provider) {
    const chainId = await provider.request({ method: "eth_chainId" });
    return Number(chainId);
  },
  async getAddress(provider) {
    const [address] = await provider.request({ method: "eth_accounts" });
    return address;
  },
  async getAddresses(provider) {
    const addresses = await provider.request({ method: "eth_accounts" });
    return addresses;
  },
  async addEthereumChain(provider, caipNetwork) {
    const rpcUrls = caipNetwork.rpcUrls["chainDefault"]?.http || [];
    await provider.request({
      method: "wallet_addEthereumChain",
      params: [
        {
          chainId: EthersHelpersUtil.numberToHexString(caipNetwork.id),
          rpcUrls: [...rpcUrls],
          chainName: caipNetwork.name,
          nativeCurrency: {
            name: caipNetwork.nativeCurrency.name,
            decimals: caipNetwork.nativeCurrency.decimals,
            symbol: caipNetwork.nativeCurrency.symbol
          },
          blockExplorerUrls: [caipNetwork.blockExplorers?.default.url],
          iconUrls: [PresetsUtil.NetworkImageIds[caipNetwork.id]]
        }
      ]
    });
  }
};

// node_modules/@reown/appkit-adapter-ethers/dist/esm/src/utils/EthersMethods.js
var EthersMethods = {
  signMessage: async (message, provider, address) => {
    if (!provider) {
      throw new Error("signMessage - provider is undefined");
    }
    const hexMessage = isHexString(message) ? message : hexlify(toUtf8Bytes(message));
    const signature = await provider.request({
      method: "personal_sign",
      params: [hexMessage, address]
    });
    return signature;
  },
  estimateGas: async (data, provider, address, networkId) => {
    if (!provider) {
      throw new Error("estimateGas - provider is undefined");
    }
    if (!address) {
      throw new Error("estimateGas - address is undefined");
    }
    if (data.chainNamespace && data.chainNamespace !== "eip155") {
      throw new Error("estimateGas - chainNamespace is not eip155");
    }
    const txParams = {
      from: data.address,
      to: data.to,
      data: data.data,
      type: 0
    };
    const browserProvider = new BrowserProvider(provider, networkId);
    const signer = new JsonRpcSigner(browserProvider, address);
    return await signer.estimateGas(txParams);
  },
  sendTransaction: async (data, provider, address, networkId) => {
    if (!provider) {
      throw new Error("sendTransaction - provider is undefined");
    }
    if (!address) {
      throw new Error("sendTransaction - address is undefined");
    }
    if (data.chainNamespace && data.chainNamespace !== "eip155") {
      throw new Error("sendTransaction - chainNamespace is not eip155");
    }
    const txParams = {
      to: data.to,
      value: data.value,
      gasLimit: data.gas,
      gasPrice: data.gasPrice,
      data: data.data,
      type: 0
    };
    const browserProvider = new BrowserProvider(provider, networkId);
    const signer = new JsonRpcSigner(browserProvider, address);
    const txResponse = await signer.sendTransaction(txParams);
    const txReceipt = await txResponse.wait();
    return txReceipt?.hash || null;
  },
  writeContract: async (data, provider, address, chainId) => {
    if (!provider) {
      throw new Error("writeContract - provider is undefined");
    }
    if (!address) {
      throw new Error("writeContract - address is undefined");
    }
    const browserProvider = new BrowserProvider(provider, chainId);
    const signer = new JsonRpcSigner(browserProvider, address);
    const contract = new Contract(data.tokenAddress, data.abi, signer);
    if (!contract || !data.method) {
      throw new Error("Contract method is undefined");
    }
    const method = contract[data.method];
    if (method) {
      return await method(...data.args);
    }
    throw new Error("Contract method is undefined");
  },
  parseWalletCapabilities: (str) => {
    try {
      return JSON.parse(str);
    } catch (error) {
      throw new Error("Error parsing wallet capabilities");
    }
  },
  parseUnits,
  formatUnits
};

// node_modules/@reown/appkit-adapter-ethers/dist/esm/src/client.js
var EthersAdapter = class extends AdapterBlueprint {
  constructor() {
    super({
      adapterType: ConstantsUtil.ADAPTER_TYPES.ETHERS,
      namespace: ConstantsUtil.CHAIN.EVM
    });
    this.balancePromises = {};
  }
  async createEthersConfig() {
    const { metadata, coinbasePreference, enableCoinbase, enableInjected, enableEIP6963 } = OptionsController.state;
    if (!metadata) {
      return void 0;
    }
    let injectedProvider = void 0;
    function getInjectedProvider() {
      if (injectedProvider) {
        return injectedProvider;
      }
      if (typeof window === "undefined") {
        return void 0;
      }
      if (!window.ethereum) {
        return void 0;
      }
      injectedProvider = window.ethereum;
      return injectedProvider;
    }
    async function getSafeProvider() {
      const { SafeProvider } = await import("./SafeProvider-IOPZPERY.js");
      const { default: SafeAppsSDK } = await import("./esm-HTRNIEEK.js");
      const appsSdk = new SafeAppsSDK();
      const info = await appsSdk.safe.getInfo();
      const provider = new SafeProvider(info, appsSdk);
      await provider.connect().catch((error) => {
        console.info("Failed to auto-connect to Safe:", error);
      });
      return provider;
    }
    async function getCoinbaseProvider() {
      const caipNetworks = ChainController.getCaipNetworks();
      try {
        const { createCoinbaseWalletSDK } = await import("./dist-WI4RFOQA.js");
        if (typeof window === "undefined") {
          return void 0;
        }
        const coinbaseSdk = createCoinbaseWalletSDK({
          appName: metadata?.name,
          appLogoUrl: metadata?.icons[0],
          appChainIds: caipNetworks?.map((caipNetwork) => caipNetwork.id) || [1, 84532],
          preference: {
            options: coinbasePreference ?? "all"
          }
        });
        return coinbaseSdk.getProvider();
      } catch (error) {
        console.error("Failed to import Coinbase Wallet SDK:", error);
        return void 0;
      }
    }
    const providers = { metadata: metadata ?? {} };
    if (enableInjected !== false) {
      providers.injected = getInjectedProvider();
    }
    if (enableCoinbase !== false) {
      const coinbaseProvider = await getCoinbaseProvider();
      if (coinbaseProvider) {
        providers.coinbase = coinbaseProvider;
      }
    }
    if (CoreHelperUtil.isSafeApp()) {
      const safeProvider = await getSafeProvider();
      if (safeProvider) {
        providers.safe = safeProvider;
      }
    }
    providers.EIP6963 = enableEIP6963 !== false;
    return providers;
  }
  async signMessage(params) {
    const { message, address, provider } = params;
    if (!provider) {
      throw new Error("Provider is undefined");
    }
    try {
      const signature = await EthersMethods.signMessage(message, provider, address);
      return { signature };
    } catch (error) {
      throw new Error("EthersAdapter:signMessage - Sign message failed");
    }
  }
  async sendTransaction(params) {
    if (!params.provider) {
      throw new Error("Provider is undefined");
    }
    const address = ChainController.getAccountData(ConstantsUtil.CHAIN.EVM)?.address;
    if (!address) {
      throw new Error("Address is undefined");
    }
    const tx = await EthersMethods.sendTransaction({
      value: Number.isNaN(Number(params.value)) ? BigInt(0) : BigInt(params.value),
      to: params.to,
      data: params.data ? params.data : "0x",
      gas: params.gas ? BigInt(params.gas) : void 0,
      gasPrice: params.gasPrice ? BigInt(params.gasPrice) : void 0,
      address
    }, params.provider, address, Number(params.caipNetwork?.id));
    return { hash: tx };
  }
  async writeContract(params) {
    if (!params.provider) {
      throw new Error("Provider is undefined");
    }
    const { address } = ParseUtil.parseCaipAddress(params.caipAddress);
    const result = await EthersMethods.writeContract(params, params.provider, address, Number(params.caipNetwork?.id));
    return { hash: result };
  }
  async estimateGas(params) {
    const { provider, caipNetwork, address } = params;
    if (!provider) {
      throw new Error("Provider is undefined");
    }
    try {
      const result = await EthersMethods.estimateGas({
        data: params.data,
        to: params.to,
        address
      }, provider, address, Number(caipNetwork?.id));
      return { gas: result };
    } catch (error) {
      throw new Error("EthersAdapter:estimateGas - Estimate gas failed");
    }
  }
  parseUnits(params) {
    return EthersMethods.parseUnits(params.value, params.decimals);
  }
  formatUnits(params) {
    return EthersMethods.formatUnits(params.value, params.decimals);
  }
  async syncConnection(params) {
    const { id, chainId } = params;
    const connector = this.connectors.find((c) => c.id === id);
    const selectedProvider = connector?.provider;
    if (!selectedProvider) {
      throw new Error("Provider not found");
    }
    const accounts = await selectedProvider.request({
      method: "eth_requestAccounts"
    });
    const requestChainId = await selectedProvider.request({
      method: "eth_chainId"
    });
    this.listenProviderEvents(id, selectedProvider);
    if (!accounts[0]) {
      throw new Error("No accounts found");
    }
    if (!connector?.type) {
      throw new Error("Connector type not found");
    }
    return {
      address: this.toChecksummedAddress(accounts[0]),
      chainId: Number(requestChainId) || Number(chainId),
      provider: selectedProvider,
      type: connector.type,
      id
    };
  }
  async syncConnectors() {
    this.ethersConfig = await this.createEthersConfig();
    if (this.ethersConfig?.EIP6963) {
      this.listenInjectedConnector(true);
    }
    const connectors = Object.keys(this.ethersConfig || {}).filter((key) => key !== "metadata" && key !== "EIP6963");
    connectors.forEach((connector) => {
      const key = connector === "coinbase" ? "coinbaseWalletSDK" : connector;
      const isInjectedConnector = connector === ConstantsUtil.CONNECTOR_ID.INJECTED;
      if (this.namespace) {
        this.addConnector({
          id: key,
          explorerId: PresetsUtil.ConnectorExplorerIds[key],
          imageUrl: AssetController.state.connectorImages?.[key],
          name: PresetsUtil.ConnectorNamesMap[key] || "Unknown",
          imageId: PresetsUtil.ConnectorImageIds[key],
          type: PresetsUtil.ConnectorTypesMap[key] ?? "EXTERNAL",
          info: isInjectedConnector ? void 0 : { rdns: key },
          chain: this.namespace,
          chains: [],
          provider: this.ethersConfig?.[connector]
        });
      }
    });
  }
  async disconnectAll() {
    const connections = await Promise.all(this.connections.map(async (connection) => {
      const connector = this.connectors.find((c) => HelpersUtil.isLowerCaseMatch(c.id, connection.connectorId));
      if (!connector) {
        throw new Error("Connector not found");
      }
      await this.disconnect({
        id: connector.id
      });
      return connection;
    }));
    return { connections };
  }
  async syncConnections({ connectToFirstConnector }) {
    const caipNetworks = this.getCaipNetworks();
    await Promise.all(this.connectors.filter((c) => {
      const { hasDisconnected, hasConnected } = HelpersUtil.getConnectorStorageInfo(c.id, this.namespace);
      return !hasDisconnected && hasConnected;
    }).map(async (connector) => {
      if (connector.id === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
        const accounts = WcHelpersUtil.getWalletConnectAccounts(this.universalProvider, this.namespace);
        const caipNetwork = caipNetworks.find((n) => n.chainNamespace === this.namespace && n.id.toString() === accounts[0]?.chainId?.toString());
        if (accounts.length > 0) {
          this.addConnection({
            connectorId: connector.id,
            accounts: accounts.map((account) => ({ address: account.address })),
            caipNetwork
          });
        }
      } else {
        const { accounts, chainId } = await ConnectorUtil.fetchProviderData(connector);
        if (accounts.length > 0 && chainId) {
          const caipNetwork = caipNetworks.find((n) => n.chainNamespace === this.namespace && n.id.toString() === chainId.toString());
          this.addConnection({
            connectorId: connector.id,
            accounts: accounts.map((address) => ({ address })),
            caipNetwork
          });
          if (connector.provider && connector.id !== ConstantsUtil.CONNECTOR_ID.AUTH && connector.id !== ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
            this.listenProviderEvents(connector.id, connector.provider);
          }
        }
      }
    }));
    if (connectToFirstConnector) {
      this.emitFirstAvailableConnection();
    }
  }
  async setUniversalProvider(universalProvider) {
    this.universalProvider = universalProvider;
    const wcConnectorId = ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
    WcHelpersUtil.listenWcProvider({
      universalProvider,
      namespace: ConstantsUtil.CHAIN.EVM,
      onConnect: (accounts) => this.onConnect(accounts, wcConnectorId),
      onDisconnect: () => this.onDisconnect(wcConnectorId),
      onAccountsChanged: (accounts) => this.onAccountsChanged(accounts, wcConnectorId, false),
      onChainChanged: (chainId) => this.onChainChanged(chainId, wcConnectorId)
    });
    this.addConnector(new WalletConnectConnector({
      provider: universalProvider,
      caipNetworks: this.getCaipNetworks(),
      namespace: ConstantsUtil.CHAIN.EVM
    }));
    return Promise.resolve();
  }
  eip6963EventHandler(event) {
    if (event.detail) {
      const { info, provider } = event.detail;
      const existingConnector = this.connectors?.find((c) => c.name === info?.name);
      if (!existingConnector) {
        const type = PresetsUtil.ConnectorTypesMap[ConstantsUtil.CONNECTOR_ID.EIP6963];
        const id = info?.rdns || info?.name || info?.uuid;
        if (type && this.namespace && id) {
          this.addConnector({
            id,
            type,
            imageUrl: info?.icon,
            name: info?.name || "Unknown",
            provider,
            info,
            chain: this.namespace,
            chains: []
          });
        }
      }
    }
  }
  listenInjectedConnector(enableEIP6963) {
    if (typeof window !== "undefined" && enableEIP6963) {
      const handler = this.eip6963EventHandler.bind(this);
      window.addEventListener(ConstantsUtil2.EIP6963_ANNOUNCE_EVENT, handler);
      window.dispatchEvent(new Event(ConstantsUtil2.EIP6963_REQUEST_EVENT));
    }
  }
  async connect({ id, address, type, chainId, socialUri }) {
    try {
      const connector = this.connectors.find((c) => HelpersUtil.isLowerCaseMatch(c.id, id));
      if (!connector) {
        throw new Error("Connector not found");
      }
      const connection = this.getConnection({
        address,
        connectorId: id,
        connections: this.connections,
        connectors: this.connectors
      });
      if (connection) {
        const caipNetwork = connection.caipNetwork;
        if (!caipNetwork) {
          throw new Error("EthersAdapter:connect - could not find the caipNetwork to connect");
        }
        if (connection.account) {
          this.emit("accountChanged", {
            address: this.toChecksummedAddress(connection.account.address),
            chainId: caipNetwork.id,
            connector
          });
          return {
            address: this.toChecksummedAddress(connection.account.address),
            chainId: caipNetwork.id,
            provider: connector.provider,
            type: connector.type,
            id
          };
        }
      }
      const selectedProvider = connector?.provider;
      if (!selectedProvider) {
        throw new Error("Provider not found");
      }
      let accounts = [];
      let requestChainId = void 0;
      if (type === ConstantsUtil2.CONNECTOR_TYPE_AUTH) {
        const { address: _address, accounts: authAccounts } = await SIWXUtil.authConnectorAuthenticate({
          authConnector: selectedProvider,
          chainNamespace: ConstantsUtil.CHAIN.EVM,
          chainId,
          socialUri,
          preferredAccountType: getPreferredAccountType("eip155")
        });
        const caipNetwork = this.getCaipNetworks().find((n) => n.id.toString() === chainId?.toString());
        accounts = [_address];
        this.addConnection({
          connectorId: id,
          accounts: authAccounts ? authAccounts.map((account) => ({ address: account.address })) : accounts.map((account) => ({ address: account })),
          caipNetwork,
          auth: {
            name: StorageUtil.getConnectedSocialProvider(),
            username: StorageUtil.getConnectedSocialUsername()
          }
        });
        this.emit("accountChanged", {
          address: this.toChecksummedAddress(accounts[0]),
          chainId: Number(chainId),
          connector
        });
      } else {
        accounts = await selectedProvider.request({
          method: "eth_requestAccounts"
        });
        requestChainId = await selectedProvider.request({
          method: "eth_chainId"
        });
        const caipNetwork = this.getCaipNetworks().find((n) => n.id.toString() === chainId?.toString());
        if (requestChainId !== chainId) {
          if (!caipNetwork) {
            throw new Error("EthersAdapter:connect - could not find the caipNetwork to switch");
          }
          try {
            await selectedProvider?.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: EthersHelpersUtil.numberToHexString(caipNetwork.id) }]
            });
          } catch (error) {
            throw new Error("EthersAdapter:connect - Switch network failed");
          }
        }
        this.emit("accountChanged", {
          address: this.toChecksummedAddress(accounts[0]),
          chainId: Number(chainId),
          connector
        });
        this.addConnection({
          connectorId: id,
          accounts: accounts.map((account) => ({ address: account })),
          caipNetwork
        });
        if (connector.id !== ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
          this.listenProviderEvents(id, selectedProvider);
        }
      }
      return {
        address: this.toChecksummedAddress(accounts[0]),
        chainId: Number(chainId),
        provider: selectedProvider,
        type,
        id
      };
    } catch (err) {
      if (ErrorUtil.isUserRejectedRequestError(err)) {
        throw new UserRejectedRequestError(err);
      }
      throw err;
    }
  }
  async reconnect(params) {
    const { id, chainId } = params;
    const connector = this.connectors.find((c) => c.id === id);
    if (connector && connector.type === "AUTH" && chainId) {
      await SIWXUtil.authConnectorAuthenticate({
        authConnector: connector.provider,
        chainNamespace: ConstantsUtil.CHAIN.EVM,
        chainId,
        preferredAccountType: getPreferredAccountType("eip155")
      });
    }
  }
  async getAccounts(params) {
    const connector = this.connectors.find((c) => c.id === params.id);
    const selectedProvider = connector?.provider;
    if (!selectedProvider || !connector) {
      throw new Error("Provider not found");
    }
    const connection = this.getConnection({
      connectorId: params.id,
      connections: this.connections,
      connectors: this.connectors
    });
    if (connection) {
      return {
        accounts: connection.accounts.map(({ address }) => CoreHelperUtil.createAccount(ConstantsUtil.CHAIN.EVM, address, "eoa"))
      };
    }
    if (params.id === ConstantsUtil.CONNECTOR_ID.AUTH) {
      const provider = connector["provider"];
      if (!provider.user) {
        return { accounts: [] };
      }
      const { accounts: accounts2, address } = provider.user;
      return Promise.resolve({
        accounts: (accounts2 || [{ address, type: "eoa" }]).map((account) => CoreHelperUtil.createAccount(ConstantsUtil.CHAIN.EVM, account.address, account.type))
      });
    }
    const accounts = await selectedProvider.request({
      method: "eth_requestAccounts"
    });
    return {
      accounts: accounts.map((account) => CoreHelperUtil.createAccount(ConstantsUtil.CHAIN.EVM, account, "eoa"))
    };
  }
  async disconnect(params) {
    if (params.id) {
      const connector = this.connectors.find((c) => HelpersUtil.isLowerCaseMatch(c.id, params.id));
      if (!connector) {
        throw new Error("Connector not found");
      }
      const connection = this.getConnection({
        connectorId: params.id,
        connections: this.connections,
        connectors: this.connectors
      });
      switch (connector.type) {
        case ConstantsUtil2.CONNECTOR_TYPE_WALLET_CONNECT:
          if (connector.provider.session) {
            ;
            connector.provider.disconnect();
          }
          break;
        case ConstantsUtil2.CONNECTOR_TYPE_AUTH:
          await connector.provider?.disconnect();
          break;
        case ConstantsUtil2.CONNECTOR_TYPE_ANNOUNCED:
        case ConstantsUtil2.CONNECTOR_TYPE_EXTERNAL:
          await this.revokeProviderPermissions(connector.provider);
          break;
        default:
          throw new Error("Unsupported provider type");
      }
      if (connector.id) {
        this.removeProviderListeners(connector.id);
        this.deleteConnection(connector.id);
      }
      if (this.connections.length === 0) {
        this.emit("disconnect");
      } else {
        this.emitFirstAvailableConnection();
      }
      return { connections: connection ? [connection] : [] };
    }
    return this.disconnectAll();
  }
  async getBalance(params) {
    const address = params.address;
    const caipNetwork = this.getCaipNetworks().find((network) => network.id.toString() === params.chainId?.toString());
    if (!address) {
      return Promise.resolve({ balance: "0.00", symbol: "ETH" });
    }
    if (caipNetwork && caipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM) {
      const caipAddress = `${caipNetwork.caipNetworkId}:${address}`;
      const cachedPromise = this.balancePromises[caipAddress];
      if (cachedPromise) {
        return cachedPromise;
      }
      const cachedBalance = StorageUtil.getNativeBalanceCacheForCaipAddress(caipAddress);
      if (cachedBalance) {
        return { balance: cachedBalance.balance, symbol: cachedBalance.symbol };
      }
      const jsonRpcProvider = new JsonRpcProvider(caipNetwork.rpcUrls.default.http[0], {
        chainId: caipNetwork.id,
        name: caipNetwork.name
      });
      if (jsonRpcProvider) {
        try {
          this.balancePromises[caipAddress] = new Promise(async (resolve) => {
            try {
              const balance = await jsonRpcProvider.getBalance(address);
              const formattedBalance = formatEther(balance);
              StorageUtil.updateNativeBalanceCache({
                caipAddress,
                balance: formattedBalance,
                symbol: caipNetwork.nativeCurrency.symbol,
                timestamp: Date.now()
              });
              resolve({ balance: formattedBalance, symbol: caipNetwork.nativeCurrency.symbol });
            } catch (error) {
              resolve({ balance: "0.00", symbol: "ETH" });
            }
          }).finally(() => {
            delete this.balancePromises[caipAddress];
          });
          return this.balancePromises[caipAddress] || { balance: "0.00", symbol: "ETH" };
        } catch (error) {
          return { balance: "0.00", symbol: "ETH" };
        }
      }
    }
    return { balance: "0.00", symbol: "ETH" };
  }
  async switchNetwork(params) {
    const { caipNetwork } = params;
    const providerType = ProviderController.getProviderId(caipNetwork.chainNamespace);
    const provider = ProviderController.getProvider(caipNetwork.chainNamespace);
    if (providerType === "AUTH" || providerType === "WALLET_CONNECT") {
      await super.switchNetwork(params);
      return;
    }
    if (!provider) {
      throw new Error("Provider not found");
    }
    try {
      await provider?.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: EthersHelpersUtil.numberToHexString(caipNetwork.id) }]
      });
    } catch (switchError) {
      if (switchError.code === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_INVALID_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_CODE_DEFAULT || switchError?.data?.originalError?.code === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
        await EthersHelpersUtil.addEthereumChain(provider, caipNetwork);
      } else if (providerType === "ANNOUNCED" || providerType === "EXTERNAL" || providerType === "INJECTED") {
        throw new Error("Chain is not supported");
      }
    }
  }
  getWalletConnectProvider() {
    return this.connectors.find((c) => c.type === "WALLET_CONNECT")?.provider;
  }
  async revokeProviderPermissions(provider) {
    try {
      const permissions = await provider.request({
        method: "wallet_getPermissions"
      });
      const ethAccountsPermission = permissions.find((permission) => permission.parentCapability === "eth_accounts");
      if (ethAccountsPermission) {
        await provider.request({
          method: "wallet_revokePermissions",
          params: [{ eth_accounts: {} }]
        });
      }
    } catch (error) {
      console.info("Could not revoke permissions from wallet. Disconnecting...", error);
    }
  }
  async getCapabilities(params) {
    const provider = ProviderController.getProvider(ConstantsUtil.CHAIN.EVM);
    if (!provider) {
      throw new Error("Provider is undefined");
    }
    return await provider.request({ method: "wallet_getCapabilities", params: [params] });
  }
  async grantPermissions(params) {
    const provider = ProviderController.getProvider(ConstantsUtil.CHAIN.EVM);
    if (!provider) {
      throw new Error("Provider is undefined");
    }
    return await provider.request({ method: "wallet_grantPermissions", params });
  }
  async revokePermissions(params) {
    const provider = ProviderController.getProvider(ConstantsUtil.CHAIN.EVM);
    if (!provider) {
      throw new Error("Provider is undefined");
    }
    return await provider.request({ method: "wallet_revokePermissions", params: [params] });
  }
  async walletGetAssets(params) {
    const provider = ProviderController.getProvider(ConstantsUtil.CHAIN.EVM);
    if (!provider) {
      throw new Error("Provider is undefined");
    }
    return await provider.request({
      method: "wallet_getAssets",
      params: [params]
    });
  }
  toChecksummedAddress(address) {
    try {
      return getAddress(address.toLowerCase());
    } catch {
      return address;
    }
  }
};
export {
  EthersAdapter,
  EthersHelpersUtil
};
//# sourceMappingURL=@reown_appkit-adapter-ethers.js.map
